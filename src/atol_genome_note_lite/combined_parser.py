#!/usr/bin/env python3

import argparse
import csv
import json
import logging
import sys
import yaml
from pathlib import Path

# configure logger
logging.basicConfig(
    stream=sys.stderr,
    level=logging.DEBUG,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger()

# add arguments
argument_parser = argparse.ArgumentParser(
    description="This tool parses files that are generated during the genome assembly pipeline and outputs them in a json format suitable for appending to an organism-sample-experiment-reads metadata json which can be used an input to the explore.py script",
    formatter_class=argparse.ArgumentDefaultsHelpFormatter,
)
input_group = argument_parser.add_argument_group("Input")
output_group = argument_parser.add_argument_group("Output")
input_group.add_argument(
    "--busco",
    type=Path,
    help="the JSON summary file generated during BUSCO analysis of the assembly - the file should end with busco.json"
)
input_group.add_argument(
    "--kmer",
    type=Path,
    help="the kmer count file generated during merqury.FK analysis of the assembly - the file should end with .completeness.stats"
)
input_group.add_argument(
    "--qv",
    type=Path,
    help="the QV scores summary file generated during merqury.FK analysis of the assembly - the file should end with .qv"
)
input_group.add_argument(
    "--summary",
    type=Path,
    help="the summary text file generated when using the sanger_tol assembly pipeline - the file should end with .assembly_summary"
)
input_group.add_argument(
    "--software",
    type=Path,
    help="the YAML file summarising the tools and versions used by the assembly pipeline - the file should end with genomeassembly_software_versions.yml"
)
input_group.add_argument(
    "--map",
    type=Path,
    nargs='?',
    help="the PreText Snapshot PNG file of the contact map generated during assembly scaffolding - the file should end with FullMap.png"
)
input_group.add_argument(
    "--kmer_plot",
    type=Path,
    nargs='?',
    help="the GenomeScope2.0 PNG file containing a linear frequency distribution graph of kmers - the file should end with linear_plot.png"
)
input_group.add_argument(
    "--mito",
    type=Path,
    nargs='?',
    help="the mitochondrion statistics TSV generated by MitoHiFi during mitogenome assembly - the file should end with contigs_stats.tsv"
)
input_group.add_argument(
    "--metadata",
    type=Path,
    nargs='?',
    help="the sample metadata JSON to which the assembly stats and metrics will be appended onto - should already include metadata for organism, sample, experiment, and runs"
)
output_group.add_argument(
    "--output",
    type=Path,
    default=Path("results/assembly_metrics.json"),
    help="a JSON output file including all assembly stats and information for inclusion in the genome note lite"
)
output_group.add_argument(
    "--full_json",
    type=Path,
    default=Path("results/full_metadata.json"),
    help="the full JSON metadata object, including metadata for organism, sample, experiment, and runs, and assembly metrics (only generated if a metadata file is included as input)"
)
args = argument_parser.parse_args()

# set global variables
json_assembly_object = {}
path_to_busco_field_mapping = "dev/busco_to_fields.csv"
path_to_kmer_field_mapping = "dev/kmer_to_fields.csv"
path_to_qv_field_mapping = "dev/qv_to_fields.csv"
path_to_summary_field_mapping = "dev/summary_to_fields.csv"

def parse_mappings(mappings):
    '''saving genome note field names to a dictionary'''
    mapping_dict = {}
    with open(mappings, "rt") as f:
        csvreader = csv.reader(f)
        next(csvreader) # take out the header
        for line in csvreader:
            mapping_dict[line[1]]=line[0]
    return mapping_dict

def map_data(mapping_dict, input_data):
    '''mapping values from a dictionary to genome note field names'''
    mapped_output = {}
    for mapped_field,original_field in mapping_dict.items():
        mapped_output[mapped_field] = input_data[original_field]
    return mapped_output

def parse_merqury(stats_file, column_for_parsing):
    '''writing a dictionary of metrics for primary, alt and combined assemblies from a tsv input file'''
    parsed_data_list = []
    with open(stats_file, "rt") as f:
        logger.info(f"Parsing Merqury.fk metrics from {stats_file}")
        stats_table = csv.reader(f, delimiter='\t')
        header_row = next(stats_table)
        stats_position = header_row.index(column_for_parsing) # define the position of the stats to be parsed in each row
        for row in stats_table:
            parsed_data_list.append(row[stats_position])
    return parsed_data_list

def map_merqury(mapping_dict, input_list):
    '''mapping values from a list parsed from merqury.fk output to genome note lite field names'''
    mapped_output = {}
    for mapped_field,row_index in mapping_dict.items():
        mapped_output[mapped_field] = input_list[int(row_index)]
    return mapped_output

logger.info("Starting script")

busco_mapping_dict = parse_mappings(path_to_busco_field_mapping)
# extract "results" and "lineage_dataset" objects from json file and merge into one dictionary
with open(args.busco, "rt") as f:
    logger.info(f"Parsing BUSCO metrics from {args.busco}")
    busco_stats = json.load(f)
    busco_for_mapping = busco_stats['results'] | busco_stats['lineage_dataset']
busco_metrics = map_data(busco_mapping_dict, busco_for_mapping)

kmer_mapping_dict = parse_mappings(path_to_kmer_field_mapping)
kmer_for_mapping = parse_merqury(args.kmer, "% Covered")
kmer_metrics = map_merqury(kmer_mapping_dict, kmer_for_mapping)

qv_mapping_dict = parse_mappings(path_to_qv_field_mapping)
qv_for_mapping = parse_merqury(args.qv, "QV")
qv_metrics = map_merqury(qv_mapping_dict, qv_for_mapping)

summary_mapping_dict = parse_mappings(path_to_summary_field_mapping)
# extract keys and values from summary text file and add to dictionary
with open(args.summary, "rt") as f:
    logger.info(f"Parsing summary information and metrics from {args.summary}")
    summary_for_mapping = {}
    next(f) #take out the header
    for line in f:
        splits = line.strip().split(": ")
        if len(splits) == 2:
            key = splits[0]
            value = splits[1]
            summary_for_mapping[key]=value
summary_metrics = map_data(summary_mapping_dict, summary_for_mapping)

# parse software tools and extract assembly pipeline version/hash
with open(args.software, "rt") as f:
    logger.info(f"Parsing software tools and versions from {args.software}")
    tool_versions = yaml.load(f, Loader=yaml.SafeLoader)
    all_wf_versions = tool_versions['Workflow'] # extract all workflow-relevant versions in a dictionary
workflow_version = {}
workflow_version['assembly_pipeline_ver'] = all_wf_versions['sanger-tol/genomeassembly'] # create dictionary mapping genome note field name to assembly workflow version

# combine parsed metrics into one dictionary
for metrics in [busco_metrics, kmer_metrics, qv_metrics, summary_metrics, workflow_version]:
    json_assembly_object.update(metrics)

# parse contigs_stats from mitogenome assembler and extract mitochondrion length
if args.mito is not None:
    with open(args.mito, "rt") as f:
        logger.info(f"Parsing mitochondrion statistics from {args.mito}")
        stats_table = csv.reader(f, delimiter='\t')
        next(stats_table) # skip the header comment
        header_row = next(stats_table) 
        stats_position = header_row.index('length(bp)')
        for row in stats_table:
            if row[0] == 'final_mitogenome':
                mito_bp = int(row[stats_position])
    mito_length = {'mito_size': mito_bp}
    json_assembly_object.update(mito_length)
else:
    logger.warning("No mitochondrial statistics provided, output will not containg mitogenome length")

# add contact map path to combined metrics dictionary
if args.map is not None:
    logger.info(f"Parsing contact map file name: {args.map}")
    contact_map = {"contact_map_image_path": str(args.map)}
    json_assembly_object.update(contact_map)
else:
    logger.warning("No contact map provided, output will not reference contact map")

# add GenomeScope2.0 kmer plot path to combined metrics dictionary
if args.kmer_plot is not None:
    logger.info(f"Parsing kmer frequency distribution graph file name: {args.kmer_plot}")
    kmer_plot = {"genomescope_image_path": str(args.kmer_plot)}
    json_assembly_object.update(kmer_plot)
else:
    logger.warning("No kmer frequency distribution graph provided, output will not reference kmer plot")

# write combined metrics output to json 
with open(args.output, "wt", encoding="utf-8") as f:
    logger.info(f"Writing output to {args.output}")
    json.dump({'assembly': json_assembly_object}, f)

# append combined assembly metrics to input metadata JSON file and write to new JSON file
if args.metadata is not None:
    with open(args.metadata, "rt", encoding="utf-8") as f:
        metadata = json.load(f)
    metadata.update({'assembly': json_assembly_object})
    with open(args.full_json, "wt", encoding="utf-8") as f:
        logger.info(f"Writing output to {args.full_json}")
        json.dump(metadata,f)
else:
    logger.info("No input metadata file included, only assembly information will be generated as JSON")